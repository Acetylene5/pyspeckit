
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link href="prettify.css" type="text/css" rel="stylesheet">
        <link rel="icon" type="image/gif" href="images/logo.ico">
        <script type="text/javascript" src="prettify.js"></script>
        <title> PySpecKit - Examples </title>
        <h2> Examples </h2>
    </head>
    <br>
    <br>
<body onload="prettyPrint()"> 
    <center>
    <table width=800>
        <tr><td>
            <code class="prettyprint">
              <!--<? readfile("../tests/simple_fit_example.py"); ?>-->
import pyspeckit

# load a FITS-compliant spectrum
spec = pyspeckit.Spectrum('10074-190_HCOp.fits')
# The units are originally frequency (check this by printing spec.xarr.units).
# I want to know the velocity.  Convert!
# Note that this only works because the reference frequency is set in the header
spec.xarr.frequency_to_velocity()
# Default conversion is to m/s, but we traditionally work in km/s
spec.xarr.convert_to_unit('km/s')
# plot it up!
spec.plotter()
# Subtract a baseline (the data is only 'mostly' reduced)
spec.baseline()
# Fit a gaussian.  We know it will be an emission line, so we force a positive guess
spec.specfit(negamp=False)
# Note that the errors on the fits are larger than the fitted parameters.
# That's because this spectrum did not have an error assigned to it.  
# Let's use the residuals:
spec.specfit.plotresiduals()
# Now, refit with error determined from the residuals:
# (we pass in guesses to save time / make sure nothing changes)
spec.specfit(guesses=spec.specfit.modelpars)

# Save the figures to put on the web....
spec.plotter.figure.savefig("simple_fit_example_HCOp.png")
spec.specfit.residualaxis.figure.savefig("simple_fit_example_HCOp_residuals.png")

# Also, let's crop out stuff we don't want...
spec.crop(-100,100)
# replot after cropping (crop doesn't auto-refresh)
spec.plotter()
# replot the fit without re-fitting
spec.specfit.plot_fit()
# show the annotations again
spec.specfit.annotate()
spec.plotter.figure.savefig("simple_fit_example_HCOp_cropped.png")
            </code>
      <tr><td><center><img align=center width=800 src="images/simple_fit_example_HCOp.png" title="Sample HCO+ spectrum fitted with a gaussian"></center></tr></td>
      <tr><td><center><img align=center width=800 src="images/simple_fit_example_HCOp_residuals.png" title="Residuals of the gaussian fit from the previous figure"></center></tr></td>
      <tr><td><center><img align=center width=800 src="images/simple_fit_example_HCOp_cropped.png" title="A zoomed-in, cropped version of the spectrum.  With the 'crop' command, the excess data is discarded."></center></tr></td>
    </table>
    <?php include 'navbar.php';?>
    </center>
    
    <!-- Example with SDSS -->
    <center>
    <table width=800>
        <tr><td>
            <code class="prettyprint">
              <!--<? readfile("../tests/test_sdss.py"); ?>-->
import pyspeckit

# Rest wavelengths of the lines we are fitting - use as initial guesses
NIIa = 6549.86
NIIb = 6585.27
Halpha = 6564.614
SIIa = 6718.29
SIIb = 6732.68

# Initialize spectrum object and plot region surrounding Halpha-[NII] complex
spec = pyspeckit.Spectrum('sample_sdss.txt', errspecnum=2)
spec.plotter(xmin = 6450, xmax = 6775, ymin = 0, ymax = 150)

# Use [SII] lines to model narrow lines, then force [NII] lines and narrow H-alpha to have same width as [SII].  
# Will fit 1 additional broad component to H-alpha (standard for AGN spectra)
# Wavelengths are all tied together
guesses = [50, NIIa, 5, 100, Halpha, 5, 50, Halpha, 50, 50, NIIb, 5, 20, SIIa, 5, 20, SIIb, 5]
tied = ['', '', 'p[17]', '', '', 'p[17]', '', 'p[4]', '', '3 * p[0]', '', 'p[17]', '', '', 'p[17]', '', '', '']

# Actually do the fit.
spec.specfit(guesses = guesses, tied = tied, annotate = False)
spec.plotter.refresh()

# Let's use the measurements class to derive information about the emission lines.
spec.measure(z = 0.05, fluxnorm = 1e-17)

# Now overplot positions of lines and annotate
y = spec.plotter.ymax * 0.85
for i, line in enumerate(spec.measurements.lines.keys()):
    x = spec.measurements.lines[line]['modelpars'][1]
    spec.plotter.axis.plot([x]*2, [spec.plotter.ymin, spec.plotter.ymax], ls = '--', color = 'k')
    try: spec.plotter.axis.annotate(spec.speclines.optical.lines[line][-1], 
        (x, y), rotation = 90, ha = 'right', va = 'center')
    except KeyError: pass

# Make some nice axis labels
spec.plotter.axis.set_xlabel(r'Wavelength $(\AA)$')
spec.plotter.axis.set_ylabel(r'Flux $(10^{-17} \mathrm{erg/s/cm^2/\AA})$')
spec.plotter.refresh()

# Print out spectral line information
print "Line   Flux (erg/s/cm^2)     Amplitude (erg/s/cm^2)    FWHM (Angstrom)   Luminosity (erg/s)"
for line in spec.measurements.lines.keys():
    print line, spec.measurements.lines[line]['flux'], spec.measurements.lines[line]['amp'], spec.measurements.lines[line]['fwhm'], \
        spec.measurements.lines[line]['lum']
        
# Notice that because we supplied the objects redshift and flux normalization, the measurements class
# automatically calculated line luminosities.  Also, it separates the broad and narrow H-alpha components. How nice!

# Save the figure
spec.plotter.figure.savefig("sdss_fit_example.png")

            </code>
      <tr><td><center><img align=center width=800 src="images/sdss_fit_example.png" title="Sample Seyfert 1 spectrum (SDSS)"></center></tr></td>
    </table>
    <?php include 'navbar.php';?>
    </center>
    
  </body>
</html>
